# webgl

**Web Graphic Library**，页面图形库；

借助`canvas`元素，使用JavaScript和[OpenGL ES](https://www.khronos.org/opengles/) 2.0 的 API，进行2D或3D图形渲染。

WebGL 程序构成:

- 控制代码（JavaScript）
- 特效代码（在GPU中执行，shader code，着色代码）

> GPU: Graphic Processing Unit,图形处理单元

# 基础概念

webgl在电脑的GPU中运行，因此需要能够在GPU上运行的代码；

这样的代码需要提供**成对**的方法；

每对方法中的一个叫**顶点着色器**，另一个叫**片段着色器**；

并且使用一种c或c++类似的强类型语言**GLSL**（GL着色语言）；

每一对组合起来称作一个Program（着色程序）；

几乎整个webgl API都是关于如何设置这些成对方法的状态值以及运行它们；

## 顶点着色器

VertexShader，作用是，计算顶点的**位置**；

根据计算出的一系列顶点位置，webgl可以对点，线和三角形在内的一些**图元**进行**光栅化**处理；

## 片段着色器

fragmentShader，对图元进行光栅化处理，需要使用片段着色器方法；

片段着色器的作用，计算出当前绘制图元中每个像素的**颜色值**；

# 着色器获取数据

着色器需要的任何数据，都需要发送到GPU；

有4种方式：

- 属性（Attributes）和缓冲
- 全局变量（Uniforms）
- 纹理（Textures）
- 可变量（Varyings）

## 属性和**缓冲**

**缓冲**

是发送到GPU的一些**二进制数据序列**，通常情况下缓冲数据包括位置，法向量，纹理坐标，顶点颜色值等，可以存储任何数据；

缓冲不是随意读取的，事实上顶点着色器运行的次数，是一个指定的**确切数字**；

每一次运行属性，会从指定缓冲中，按照指定规则依次获取下一个值；

**属性**

用来指明怎么从缓冲中获取所需数据，并将它提供给顶点着色器；

例如你可能在缓冲中用3个32位浮点型数据存储一个**位置**；

对于一个确切的属性，需要告诉它：从哪个缓冲中获取数据，什么类型的，起始偏移值，到下一个位置的字节数是多少；

## 全局变量

在着色程序运行前赋值，在运行过程中全局有效；

## **纹理**

是一个**数据序列**，可以在着色程序运行中随意读取其中的数据；

大多数情况存放的是**图像数据**，但纹理仅仅是数据序列，也可以随意存放**除了颜色数据**以外的其他数据；

## 可变量

是一种顶点着色器给片段着色器**传值**的方式；

依照渲染的图元是点，线还是三角形，顶点着色器中设置的可变量，会在片段着色器运行中获取不同的**插值**；

## 裁剪空间

webgl只关心两件事：裁剪空间中的坐标值和颜色值；

webgl只关心两件事：裁剪空间的**坐标值**和**颜色值**；

**顶点着色器**提供坐标值，**片段着色器**提供颜色值；

无论画布多大，，裁剪空间的**坐标范围**永远是-1到1；
例子:

从顶点着色器开始

```js
// 一个属性值，将会从缓冲中获取数据
attribute vec4 a_position;
 
// 所有着色器都有一个main方法
void main() {
 
  // gl_Position 是一个顶点着色器主要设置的变量
  gl_Position = a_position;
}
```

如果用js代替glsl，当它运行的时候，做了类似以下的事情：

```js
var positionBuffer = [
  0, 0, 0, 0,
  0, 0.5, 0, 0,
  0.7, 0, 0, 0,
];
var attributes = {};
var gl_Position;
 
drawArrays(..., offset, count) {
  var stride = 4;
  var size = 4;
  for (var i = 0; i < count; ++i) {
     // 从positionBuffer复制接下来4个值给a_position属性
     const start = offset + i * stride;
     attributes.a_position = positionBuffer.slice(start, start + size);
     runVertexShader();// 运行顶点着色器
     ...
     doSomethingWith_gl_Position();
}
```

但实际情况没那么简单，因为**positionBuffer**将会被转换成二进制数据；

接着看片段着色器：

```js
// 片段着色器没有默认精度，所以我们需要设置一个精度
// mediump是一个不错的默认值，代表“medium precision”（中等精度）
precision mediump float;
 
void main() {
  // gl_FragColor是一个片段着色器主要设置的变量
  gl_FragColor = vec4(1, 0, 0.5, 1); // 返回“红紫色”
}
```



# 操作

## 上下文环境

如何设置 WebGL 上下文环境？

```html
<body onload="main()">
  <canvas id="glcanvas" width="640" height="480">
    你的浏览器似乎不支持或者禁用了 HTML5 <code>&lt;canvas&gt;</code> 元素。
  </canvas>
</body>
<script>
// 从这里开始
function main() {
  const canvas = document.querySelector("#glcanvas");
  // 初始化 WebGL 上下文
  const gl = canvas.getContext("webgl");

  // 确认 WebGL 支持性
  if (!gl) {
    alert("无法初始化 WebGL，你的浏览器、操作系统或硬件等可能不支持 WebGL。");
    return;
  }

  // 使用完全不透明的黑色清除所有图像
  gl.clearColor(0.0, 0.0, 0.0, 1.0);
  // 用上面指定的颜色清除缓冲区
  gl.clear(gl.COLOR_BUFFER_BIT);
}

</script>
```

获取到 canvas 之后，调用[getContext](https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLCanvasElement/getContext) 函数并向它传递 `"webgl"` 参数，来尝试获取[WebGLRenderingContext](https://developer.mozilla.org/zh-CN/docs/Web/API/WebGLRenderingContext);

如果浏览器不支持 webgl, `getContext` 将会返回 `null`，就可以显示一条消息给用户然后退出;

如果 WebGL 上下文成功初始化，变量‘gl’会用来引用该上下文;

在这个例子里，用黑色清除上下文内已有的元素。（用背景颜色重绘 canvas）;

![image-20241008155038443](D:\workspace\zsfBlog\my-blog\docs\前端\img\image-20241008155038443.png)

## 2D内容

如何用 WebGl 渲染简单的平面化图形?

### 渲染场景

### 创建对象

### 绘制场景

### 矩阵通用计算